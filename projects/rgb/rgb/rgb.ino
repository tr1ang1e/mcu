
/* pins 
 *
 * пины, для которых сконфигурирован PWM,
 * и соответствующие им таймеры можно найти:
 *    файл = pins_arduino.h
 *    массив = digital_pin_to_timer_PGM[]
 *        index = номер пина
 *        value = имя таймера
 * 
 * имя таймера представляет из себя числовую константу, 
 * по имени таймера можно найти соответствующие 
 * конфигурационные регистры в функции analogWrite()
 * 
 * e.g. Arduino Nano:
 *    pins 5, 6   >>  TIMER0
 *    pins 9, 10  >>  TIMER1 
 *    pins 3, 11  >>  TIMER2
 */
#define R_PIN 9 
#define G_PIN 11
#define B_PIN 3


/* duty
 * 
 * S (скважность) = T / t 
 * D (коэффициент заполнения, duty cycle) = t / T 
 * 
 * T = длительность всего импульса (длительность макс. напряжения + длительность мин. напряжения)
 * t = длительность максимального напряжения
 * 
 * размерность величины:
 *   - по умолчанию = 8 бит
 *   - возможна 9 и 10 бит (см. Atmega328P datasheet, 15. 16-bit Timer/Counter1 with PWM, Table 15-5)
 * тип данных 'int' т.к. соответствующий аргумент функции 'analogWrite' типа 'int'  
 * значения:
 *   0    >>  duty cycle = 0, т.е. отсутствие напряжения на пине, LOW
 *   max  >>  duty cycle = 1, т.е. только напряжение на пине, HIGH
 * 
 */
int R_duty = 0;
int G_duty = 0;
int B_duty = 0;


/* frequency
 * Принцип работы микрочипа и соответствующих часов
 *      
 * Источник тактов  >>  Делитель частоты (prescaler)  >>  AVR Clock Control Unit  >>  Конкретные часы [1]
 * По умолчанию для Atmega328 [2]:
 *      источник  =  internal RC oscillator, 8 MHz 
 *      делитель  =  8, следовательно, частота = 1 MHz
 * По умолчанию для Arduino Nano [см. даташит]
 *      источник  =  low power cristal oscillator (смонтирован на плате), 16 MHz
 *      делитель  =  1 (см. avr/.../boards.txt  >>  ...bootloader.low_fuses=0xFF  >>  CKDIV8 = 1 (CLKPS3..0 = 1111) + CKSEL3..0 = 1111
 * 
 * Все три таймера 0..2 при размерности 8 бит по умолчанию питаются от CLKi/o  [3]
 * TIMER2 может быть асинхронно сконфигурирован от внешнего источника тактов   [4] 
 * 
 * Доступные делители тактовой частоты: 1, 8, 64, 256, 1024  [5]
 * Регистры для конфигурации: TCCRnA, TCCRnB (n = номер таймера) 
 * [!] регистры настраиваются по-разному для каждого из таймеров
 * 
 * Режимы PWM [6]:
 *    Fast PWM = ( Fclk / N ) / 256                                     // 256 = количество бит, определяющее resolution таймера (итерация LOW-TOP)
 *    Phase Correct PWM (default configs) = ( Fclk / N ) / 510          // 510 = 256 * 2 - 2 (т.к. итерация происходит в обе стороны: LOW-TOP-LOW)
 * 
 * Atmega328P datasheet:
 *   [1] 8.1.1
 *   [2] 8.2.1, 8.12.2
 *   [3] 16.1, 17.3
 *   [4] 17.3   
 *   [5] 14.9.2, 15.11.2, 17.11.2      
 *   [6] 14.7.3-4, 15.9.3-4, 17.7.3-4        
 * 
 * 
 *
 * Рассчет допустимой частоты:
 *      1. звуковые эффекты = частота выше воспринимаемой человеком > 20 кГц
 *      2. характеристики транзистора = частота должна быть допустимой, чтобы транзистор успевал полностью открыться/закрыться за время одного импульса
 *              > транзистор (см. даташит, схема 'Switching time waveforms')
 *                  Т_op ~ (Т_delay(on) + Т_rise) * k_safe
 *                  Т_cl ~ (Т_delay(off) + Т_fall) * k_safe
 *                  * k_safe = запас = характеристики в даташите даются для конкретных значений, отличных от используемых в проекте
 *              > ШИМ:
 *                  Т_импульса = 1 / F
 *                  Т_op = T_импульса * Duty
 *                  Т_cl = T_импульса - T_op
 * 
 * Пример рассчета:
 * 
 *      желаемая частота F  = 31.4  кГц
 *      Т_delay(on)         = 14    нс
 *      Т_rise              = 101   нс
 *      Т_delay(off)        = 50    нс
 *      Т_fall              = 65    нс
 *      k_safe              = 1.2
 * 
 *      T_импульса = 1 / 31400 Гц = 0,000032 с = 32 мкс = 32 000 нс
 *      Т_op_транз = (14 + 101) * 1.2 = 140 нс
 *      T_cl_транз = (50 + 65) * 1.2 = 140 нс
 * 
 *      Суммарное время открытия и закрытия транзистора (280 нс) в сто раз меньше времени импульса,
 *      на обеспечение которого способен ШИМ сигнал. Следовтельно, для корректной работы необходимо лишь
 *      ограничить коэффициент заполнения (duty) чтобы отдельный сигнал (T_op_шим и T_close_шим) 
 *      был дольше, чем время открытия / закрытия транзистора
 * 
 *      D_min = Т_op_транз / Т_импульса = 140 / 32000 = 0,004375 = 0.4375 %  
 *      D_max = (Т_импульса - T_cl_транз) / Т_импульса = 31860 / 32000 = 99.5625 %
 * 
 *      При использовании PWM с разрешением 8bit (= 256 делений):
 *      D_min = 1 / 256 = 0.3906 %
 *      D max = 255 / 256 = 99.6094 %
 *      
 *      Следовательно для: 
 *          - заданной частоты генерации PWM 
 *          - заданного разрешения PWM регистра
 *      [!] необходимо ограничивать Duty параметр:  2 <= D <= 254 
 *      
 */                 

// таймер 1 (пины 9, 10) - 31.4 кГц
#define T1_A_VALUE   0b00000001
#define T1_B_VALUE   0b00000001

// таймер 2 (пины 3, 11) - 31.4 кГц
#define T2_A_VALUE   0b00000001
#define T2_B_VALUE   0b00000001



void set_new_color(int R, int G, int B, byte bright)
{
    analogWrite(R_PIN, (R * bright) / 100);
    analogWrite(G_PIN, (G * bright) / 100);
    analogWrite(B_PIN, (B * bright) / 100);
}

byte count = 0;
byte shift = 0;
unsigned long delayTime = 0.05 * 1000;      // секунды в миллисекунды
byte brightness = 20;                       // в процентах

void setup()
{
    // configure timers
    TCCR1A = T1_A_VALUE;  
    TCCR1B = T1_B_VALUE;  
    TCCR2A = T2_A_VALUE;
    TCCR2B = T2_B_VALUE;

    // set RGB pin modes
    pinMode(R_PIN, OUTPUT);
    pinMode(G_PIN, OUTPUT);
    pinMode(B_PIN, OUTPUT);
}

void loop()
{
    delay(delayTime);
    ++count;

    if (count > 170) 
    {
        shift = (count - 170) * 3;
        R_duty = shift;
        G_duty = 0;
        B_duty = 255 - shift;
    } 
    else if (count > 85) 
    {
        shift = (count - 85) * 3;
        R_duty = 0;
        G_duty = 255 - shift;
        B_duty = shift;
    } 
    else 
    {
        shift = count * 3;
        R_duty = 255 - shift;
        G_duty = shift;
        B_duty = 0;
    }

    set_new_color(R_duty, G_duty, B_duty, brightness);
}
